import numpy as np, requests, os
import subprocess
from scipy.io import wavfile
from matplotlib import pyplot as plt
from IPython.display import Audio

plt.style.use('fivethirtyeight')

# Alcuni suoni giÃ  pronti
def coefficienti_fourier(strumento):
    if strumento == 'violin':
        c = [2385.9130774675123, 1450.024553217034, 1177.6232998703272, -651.3060564259322, -1761.8892431854158, 227.99866064788662, 800.8317907320871, 400.03398225585414, -12.405887695362756, -187.16780291255884, -105.01375814678113, 10.71687054992091, 56.32488891750026, 49.30841730781574, 13.830836448478305, -11.882577333389525, -9.664488599734446, -4.649518799220516, 0.6010750931238726, 4.054796288613343, 2.242323610229901, -1.3956152142106784]
        s = [1365.4375806932758, 761.9091515185655, -1008.5284206221069, -2643.229703405079, 50.74996697065089, 1369.247319056265, 405.58331493398305, -235.0339846501416, -313.17437690604584, -85.20643199245892, 101.99089518133154, 84.60394249452114, 57.05029174711779, -8.983005209744515, -25.523496295285334, -10.48936870912723, 2.6830132511046108, 7.019855763168857, 5.758715892664451, 3.126184104918881, -2.569063025113542, -1.6616733053954025]
    elif strumento == 'trumpet':
        c = [2385.9130774675123, 1450.024553217034, 1177.6232998703272, -651.3060564259322, -1761.8892431854158, 227.99866064788662, 800.8317907320871, 400.03398225585414, -12.405887695362756, -187.16780291255884, -105.01375814678113, 10.71687054992091, 56.32488891750026, 49.30841730781574, 13.830836448478305, -11.882577333389525, -9.664488599734446, -4.649518799220516, 0.6010750931238726, 4.054796288613343, 2.242323610229901, -1.3956152142106784]
        s = [1365.4375806932758, 761.9091515185655, -1008.5284206221069, -2643.229703405079, 50.74996697065089, 1369.247319056265, 405.58331493398305, -235.0339846501416, -313.17437690604584, -85.20643199245892, 101.99089518133154, 84.60394249452114, 57.05029174711779, -8.983005209744515, -25.523496295285334, -10.48936870912723, 2.6830132511046108, 7.019855763168857, 5.758715892664451, 3.126184104918881, -2.569063025113542, -1.6616733053954025]
    elif strumento == 'clarinet':
        c = [-1976.4711955360272, 881.9122495002458, 1958.0916741171727, -358.9795525209249, -46.828623851610004, 28.11487823063465, 38.95128341516447, -24.571495922964118, -35.696954742004756, 24.991995576219434, 9.366120113251956, -11.79776258438692, -16.340500801698973, 5.016607823190969, 0.6944493568202625, -0.7488885969561058, -2.3189591760214037, -0.24727180769136944, 0.3849836469686293, -0.541346861167206, 2.390371977199138, 0.9590784022578325]
        s = [-1864.3096881195431, 672.9367229401408, 732.1090261381894, 127.71030213681469, 107.74335426449477, -119.21977068454957, 180.0959331031979, -23.78826576503125, -3.0848536670746283, -39.89895433615057, 25.579159368988986, 25.99837106440402, -6.931849215734227, 2.397341433400584, -0.1901054728615766, 2.0579761585958947, -0.31309477789661605, 0.6227010945237229, 1.3043724895775493, -0.9918888929232011, 1.745772554092051, -0.14515033008079326]
    elif strumento == 'flute':
        c = [-3774.1054007105154, -1316.5029158072846, -418.3453739219559, -99.33837696050036, 413.4488288092121, 113.35065005419395, 12.685860116083841, 51.963185300232986, -20.0608433541979, 17.279904802486808, 1.1601953229139343, -8.825774356897739, 4.404270698949069, -1.864451034465771, 3.3066215242536368, 0.9535767430353351, 0.09989672756248465, 0.9380903374322404, -4.060676312868882, -0.2689582378582414, 1.0864862462128189, -0.1785634915099183]
        s = [-2561.0250729595987, 3020.7448581882772, 480.8481233384393, -756.3443345876623, 249.4076752152805, 8.380079491965418, -39.933431521910975, 19.665730941250345, -14.116779516530462, -0.833600633992928, 9.086228415172526, -5.924745311076783, -3.158923805725405, -2.9502410647402217, -1.7688284527739133, 0.6605235765225358, -0.743317323773842, 0.5146712725772302, -1.4145345107510021, 0.8483875684427428, -1.7384037611528504, 0.7695551179089042]
    elif strumento == 'oboe':
        c = [-1603.3095698643504, -1845.510495106737, 2836.102403059012, 251.5569522573351, 451.1095117909853, 343.1149663374186, -64.66343136995677, -565.206046494734, -164.9525075967287, -9.176730945178543, -26.62636169295877, -7.760521557536974, 13.02800262835347, -21.920662792049985, -7.814300906846515, -3.3209260357541526, 7.394993975063437, 4.236873974529448, -18.530378465251157, -17.44066912055642, 4.026494486334278, -3.252384004233897]
        s = [-512.1767469159371, 5903.246226649443, -1240.096204438549, -3114.5776885752907, -351.70392160409426, -1155.7332598723947, 405.85093512700314, -648.8734818173667, 93.74509660537534, -131.65055453419026, 340.67104509041525, -46.43598502406301, 14.239422302734585, 20.290427367535543, -4.090122411035854, -1.2545717456766703, -4.5258108785913125, -32.010826276807585, 8.673907650797085, 17.419688878601406, 10.697300694638795, -4.273043211693919]
    elif strumento == 'bass-trombone':
        c = [636.1250857491359, -1317.7314292509798, -619.0613346198988, 3707.26353553119, 2744.8208799192726, -3092.5712883598135, -3124.1483020263117, 912.5812344487856, 3274.6521255634466, -254.71106274131338, -2148.085105242353, -100.80662629360413, 2282.7989018954568, 1132.077667892821, -812.5263330352668, -767.9841396624098, 425.7735901739746, 471.0533569417947, -328.7192858190935, -272.6247663881932, 242.62900578061206, 218.5976383979894, -176.9135344365132, -155.8402661024141, 129.60871742388352, 104.76033462525302, -106.34185922187706, -65.84837902182305, 61.245554951363424, 55.2235368179822, -33.31593799719532, -34.86960809081127, 21.6159376370778, 17.546821509050233, -12.738816377208355, -16.351598980774924, 5.003781846892555, 16.15615324174087, -6.172679965933483, -13.34308017629105, 0.19942195824599748, 20.113494369322158, 9.453747761653437, -9.172729132323564, -3.526468993723186, 10.508483247917919, 4.660615571158576, -9.350303851103238, -1.641737153427572, 10.627379796153349, 0.5367860935734227, -4.924738704810811, -0.6990359639264783, 4.614435486794621, -4.696960769519764, -3.903633153573049, 4.570790766562264, 2.360466787845421, -3.370031108985225, -0.20930484310818678, 3.6344116068273213, 0.14350155678013615, -1.6637168758009413, 1.504616473584962, 1.8530943871482102, -3.1565821024446463, -4.626173040652287, 1.4499413794184504, 1.3060164290343994, -1.8713608374450357, 2.2332050942369226, 5.494903697590883, -3.4886348877288387, -4.973842315190653, 5.40200710230587, 9.978482293834457, -1.9831433337765945, -6.129154630091652, 2.8679976616609615, 1.8118576262308645, -3.8606949747644057, -0.56253663658761, 6.196981870313633, 0.27170827678746784, -3.6089032662279266, 1.0683794372347752, 6.292287075669882, -2.412977230663921, -8.461525995131689, -0.44310696753195705]
        s = [715.1254626851533, 2092.503525173654, -1962.3166376705442, -1856.2093303614165, 2182.6326128689616, 2379.3967274316656, -2627.183820851924, -3328.5461383210436, 537.8613366312939, 2645.084470658204, 195.57597382078202, -2259.1120099931527, -795.2118265625181, 1434.818691109909, 935.8097066307138, -580.4434828878591, -497.7762055486022, 380.76400159924026, 320.5370306697576, -307.3519844604603, -236.30929235625018, 210.61261829914625, 154.1652260828643, -159.5639466205595, -120.79233944143937, 112.00250840586124, 82.49773983106739, -71.74158752215017, -55.49778823250099, 36.95894318447114, 48.80242181866631, -26.190504607457054, -28.399424995410794, 17.737292773406317, 13.839749177921114, -7.923011471146599, -12.398349375167184, 4.958700679551645, 15.635668263242328, -1.2337793194363644, -12.788445209741852, -1.2123713355427777, 13.130843585201701, 6.28613078650314, -6.698426414935748, 0.49211769753631057, 10.162237081365214, 4.319932625868598, -6.691546840533624, -0.2360056531349068, 7.881742236951561, -0.22770307274680088, -5.011481689195061, 4.004882662227509, 5.679389010236251, -5.09686650819161, -3.3551112900035296, 2.611244251976195, 1.321851097692859, -3.002714019458306, 0.6380848471471847, 3.1867706700046172, -0.5095548617913049, -2.3495168157339825, 2.4225072120263746, 0.6359162134480736, -4.217359718821951, -2.523047759407285, 0.6065649899987925, -1.1375889486440234, -2.642800599189098, 3.637874840370685, 4.495055797220008, -4.488974562594323, -8.89867514108909, 2.471495723571502, 5.789779142393728, -2.2526347951734333, -5.474211305083798, 2.0286872460458407, 0.3865673444936355, -5.410836583421893, -0.19343138060860934, 6.033885531920968, -0.5461842317473149, -3.196164166324049, 1.2741755598651898, 6.31467662547319, -2.759090037260598, -7.42679313131345]
    elif strumento == 'cello':
        c = [1485.1243437046812, 2231.9954397335796, -2245.909618297361, 1807.9805836436901, 1024.340982687808, -200.9886455501419, -464.2317132797996, 32.97238203719594, 40.023622014513776, -127.16739003727888, 53.192332818109136, 38.73014067216339, 1.082359468264436, 67.67795134875558, -65.27810210543718, 50.31084226703235, 0.46810086714207116, -13.346352598694828, 27.756499665909175, -53.64046319135158, 50.087901100434365, -22.92814929559938]
        s = [639.8325967280342, -109.91108683159693, -505.06829878681145, -1372.1643806656039, 1484.498091371685, 7.8015357410844235, -324.60105974149553, 22.839310908895616, -143.17089536927304, -72.67679004404765, 19.28398634534647, -10.352985246509126, 28.469432695111053, -9.344372704225352, 31.034944586902654, -45.31515475403113, -40.37728670401444, -0.6037154224564597, -27.524622182627397, -14.857197199245096, 12.565498929732401, -33.68771986761208]
        
    return c, s


def sound(v):
  v = v / np.max(np.abs(v))
  wavfile.write("output.wav", 44100, (2**13 * v).astype(np.int16))
  return Audio("output.wav")

def unisci(*args):
  return np.concatenate(args)

"""NOTA2FREQ Determina la frequenza di una nota

 F = NOTA2FREQ(NOMENOTA);
 
 Le note vanno espresse secondo la seguente notazione:

   Do4 -> Do centrale
   Do5 -> Do all'ottava sopra
   
 Altri esempi: Sol#2, Mib3, Fa##4 (:= Sol4) ...

 Il codice non Ã¨ case sensitive, i.e., 'Sol2', 'sol2, 'SOL2' rappresentano
 tutti la stessa nota.
"""
def nota2freq(nota):
  freq = np.log2(220) + 1 / 4;

  # Separiamo il nome della nota da diesis e ottave
  octave = 0
  leggendo_nome_nota = True;
  nome_nota = "";
  sharps = 0; flats = 0; # Numero di diesis o bemolle

  for j in range(len(nota)):
    if leggendo_nome_nota:
      if ord(nota[j]) < 65 or ord(nota[j]) > 122:
        leggendo_nome_nota = False
        nome_nota = nota[0 : j]
    
    if not leggendo_nome_nota:
      if nota[j] == '#':
        sharps = sharps + 1;
      elif nota[j] == 'b':
        flats = flats + 1;
      else:
        octave = int(nota[j:]) - 4

  # Aggiustiamo la frequenza con l'ottava
  freq = freq + octave

  # Aggiungiamo eventuali diesis o bemolle
  freq = freq + (sharps - flats) / 12.0;

  # E infine regoliamo la frequenza in base alla posizione nella scala
  nome_nota = nome_nota.lower()
  if nome_nota == 'do':
    pass
  elif nome_nota == 're':
    freq = freq + 2 / 12;
  elif nome_nota == 'mi':
    freq = freq + 4 / 12;
  elif nome_nota == 'fa':
    freq = freq + 5 / 12;
  elif nome_nota == 'sol':
    freq = freq + 7 / 12;
  elif nome_nota == 'la':
    freq = freq + 9 / 12;
  elif nome_nota == 'si':
    freq = freq + 11 / 12;
  else:
    raise RuntimeException('Nome nota non supportato')
    
  # Calcoliamo 2^freq
  freq = np.power(2, freq)

  return freq

def download_file(name):
  a = requests.get('http://people.cs.dm.unipi.it/robol/matematica-musica/%s' % name)
  with open(name, 'wb') as h:
    h.write(a.content)

def download_sounds():
  download_file('flute_A4.wav')
  download_file('great-organ_A3.wav')
  download_file('strings_A3.wav')

def analizza_suono(nomefile, freq_base = None):
  if isinstance(nomefile, str):
    Fs, s = wavfile.read(nomefile);
    # Per suoni stereo, selezionamo solo uno dei canali. 
    if s.ndim > 1:
      s = s[:,0]
  else:
    s = nomefile;
    Fs = 44100;

  # Facciamo una copia del suono per intero che ci servirÃ  piÃ¹ tardi, mentre
  # s verrÃ  tagliato a solo una parte iniziale per meglio identificare le
  # frequenze. 
  s_intero = s;

  # Teniamo solo la parte iniziale del suono -- questo ci permette di
  # ignorare il fatto che durante un suono lungo i coefficienti di Fourier
  # cambiano un po'. 
  s = s[8192 : 16384];

  # Calcoliamo la trasformata di Fourier discreta dei sample. Questa Ã¨ una 
  # trasformata fatta utilizzando i numeri complessi, e restituisce dei 
  # valori da cui si possono ricavare i coefficienti a_i, b_i della serie
  # di Fourier come li abbiamo introdotti noi.
  sf = np.fft.fft(s);
  sf = sf / np.max(np.abs(sf));

  # Leggiamo le frequenze prendendo la prima metÃ  del suono (ovvero estraiamo
  # gli a_i). 
  l = int(np.ceil((len(sf) + 1) / 2));
  freqs = np.abs(sf[0:l]);

  x = ( np.array(range(0, l)) / l * Fs / 2);

  fig = plt.figure(figsize = [ 15, 7 ])
  plt.subplot(1, 2, 1);

  ind = np.array(range(int(np.floor(Fs * 0.1)), int(np.floor(Fs * 0.12))));
  plt.plot(ind / Fs, s_intero[ind]);
  plt.xlabel('t');
  plt.ylabel('s(t)');
  plt.title('Forma d\'onda');

  # set(gcf, 'position', [ 400 400 1400 700 ]);
  ax = plt.subplot(1, 2, 2);
  plt.semilogy(x, freqs);

  # Zoomiamo nel range interessante, dove ci sono le frequenze
  # ragionevolmente udibili per noi. 
  plt.axis([ 0, 4000, 0.5 * np.min(freqs), 1.1 * np.max(freqs) ]);

  plt.title('Coefficienti di Fourier');
  plt.xlabel('Frequenza (Hz)');
  plt.ylabel('Coefficiente di Fourier');

  # TODO: Identifichiamo la frequenze massime
  if freq_base is not None:
    ntones = int(4000 / freq_base)
    indices = []
    c = np.zeros(ntones)
    ss = np.zeros(ntones)
    for j in range(1, ntones+1):
      jj = freq_base * l * 2.0 * j / Fs
      j1 = int(freq_base * l * 2.0 * (j - .3) / Fs)
      j2 = int(freq_base * l * 2.0 * (j + .3) / Fs)
      # c[j-1] = np.max(freqs[j1 : j2])
      idx = np.argmax(freqs[j1 : j2])
      indices.append(j1 + idx)
      val = sf[j1 + idx]
      #if c[j-1] < 1e-2:
      #  c[j-1] = 0.0
      if abs(val) > 1e-2:
        c[j-1] = np.real(val)
        ss[j-1] = np.imag(val)
      else:
        c[j-1] = 0.0
        ss[j-1] = 0.0

    # plt.scatter(1 + freq_base * np.arange(1,ntones+1), np.hypot(c, ss), color='red')
    plt.scatter(x[indices], np.hypot(c, ss), color='red')

    return c, ss

download_sounds()

# Il codice qui sotto implementa quello che Ã¨ richiesto per registrare audio 
# dal browser

from IPython.display import Javascript
from base64 import b64decode
from io import BytesIO
from pydub import AudioSegment

RECORD = """
const sleep  = time => new Promise(resolve => setTimeout(resolve, time))
const b2text = blob => new Promise(resolve => {
  const reader = new FileReader()
  reader.onloadend = e => resolve(e.srcElement.result)
  reader.readAsDataURL(blob)
})

var record = time => new Promise(async resolve => {
  stream = await navigator.mediaDevices.getUserMedia({ audio: true })
  recorder = new MediaRecorder(stream)
  chunks = []
  recorder.ondataavailable = e => chunks.push(e.data)
  recorder.start()
  await sleep(time)
  recorder.onstop = async ()=>{
    blob = new Blob(chunks)
    text = await b2text(blob)
    resolve(text)
  }
  recorder.stop()
})
"""

from ipywebrtc import AudioRecorder, CameraStream
from IPython.display import Audio

def registra():
    camera = CameraStream(constraints={'audio': True,'video':False})
    recorder = AudioRecorder(stream=camera)
    return recorder

def salva_registrazione(recorder):
    with open('recording.webm', 'wb') as f:
        f.write(recorder.audio.value)
    p = subprocess.call([ 'ffmpeg', '-i', 'recording.webm', '-ac', '1', '-f', 'wav', 'file.wav', '-y', '-hide_banner', '-loglevel', 'panic' ])